---
layout: post
title: Leetcode|As Far from Land as Possible|Python
---

é¢˜ç›®å¤§æ„ï¼šç»™ä¸€ä¸ªN * Nçš„ç½‘æ ¼ï¼Œ æ¯ä¸ªç½‘æ ¼æ˜¯0æˆ–1ï¼Œ 0ä»£è¡¨æ°´ï¼Œ1ä»£è¡¨é™†åœ°ï¼Œæ‰¾åˆ°ä¸€ä¸ªæ°´ç½‘æ ¼ä½¿å¾—å®ƒåˆ°å®ƒæœ€è¿‘çš„é™†åœ°è·ç¦»æ˜¯åœ¨æ‰€æœ‰æ°´ç½‘æ ¼åˆ°æœ€è¿‘é™†åœ°è·ç¦»ä¸­æ˜¯æœ€è¿œçš„ã€‚
ä»»æ„ä¸¤ä¸ªç½‘æ ¼ä¹‹é—´çš„è·ç¦»å…¬å¼ä¸º|x0 - x1| + |y0 - y1|ã€‚å¦‚æœæ²¡æœ‰é™†åœ°æˆ–è€…æ²¡æœ‰æ°´ï¼Œ è¿”å›-1ã€‚

é¢˜ç›®è¯¦è§£ï¼šæœ¬é¢˜æ€è·¯æ¯”è¾ƒå·§å¦™ã€‚æŒ‰ç…§æ­£å¸¸é€»è¾‘ï¼Œ æˆ‘ä»¬ä¼šéå†gridï¼Œ å¯¹äºæ¯ä¸€ä¸ªæ˜¯æ°´çš„ç½‘æ ¼è¿›è¡Œbfså‘å››å‘¨æ‰©æ•£ï¼Œ æ‰¾åˆ°ä¸€ä¸ªé™†åœ°ç«‹åˆ»è¿”å›ï¼Œ å³è¯¥æ°´ç½‘æ ¼åˆ°æœ€è¿‘é™†åœ°çš„æœ€çŸ­
è·ç¦»ã€‚ç„¶åæŠŠæ‰€æœ‰çš„æœ€çŸ­è·ç¦»è¿›è¡Œæ¯”è¾ƒæ‰¾åˆ°æœ€é•¿çš„ã€‚ä½†æ˜¯è¿™æ ·è€—æ—¶å¤ªä¹…ï¼Œ æ˜¯æ— æ³•é€šè¿‡çš„ã€‚

åæ–¹å‘æ€è€ƒğŸ˜”ï¼Œ å¦‚æœæˆ‘ä»¬ä¸ä»æ°´å‡ºå‘bfsï¼Œ å¦‚æœä»¥é™†åœ°ä¸ºåŸºå‡†bfså‘å››å‘¨ï¼ˆä¸Šä¸‹å·¦å³ï¼‰æ‰«ï¼Œ é‚£ä¹ˆå…ˆæ‰«åˆ°çš„å°±æ˜¯è·ç¦»é™†åœ°çš„æœ€è¿‘è·ç¦»ï¼Œ è¿™æ ·è®²å¤§å¤§åŠ å¿«æ•ˆç‡ã€‚ å½“æ‰€æœ‰ç½‘æ ¼
éƒ½è¢«æ‰«è¿‡ï¼Œ æ‰€æœ‰æ°´ç½‘æ ¼åˆ°é™†åœ°çš„æœ€å°è·ç¦»ä¹Ÿå°±éƒ½å‡ºæ¥äº†ï¼Œ ä»ä¸­é€‰å–æœ€å¤§çš„å³å¯ã€‚

ç®—æ³•ï¼šfloodfillï¼ˆbfsï¼‰

```python
class Solution(object):
    def maxDistance(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        m = len(grid[0])
        n = len(grid)
        sum = 0
        queue = []
        for i in range(m):
            for j in range(n):
                sum += grid[i][j]
                #å…ˆæŠŠæ‰€æœ‰é™†åœ°çš„ç½‘æ ¼åŠ åˆ°é˜Ÿåˆ—é‡Œé¢
                if grid[i][j] == 1:
                    queue.append((i, j, 0))
        #å…¨æ˜¯é™†åœ°æˆ–å…¨æ˜¯æ°´ï¼Œ è¿”å›-1ã€‚
        if sum == 0 or sum == m * n:
            return -1
        #å»ºç«‹ä¸€ä¸ªå…¨æ˜¯0çš„ç›¸åŒå¤§å°ç½‘æ ¼ï¼Œåæ–¹å‘æ€è€ƒï¼Œ ä»¥é™†åœ°ä¸ºåŸºå‡†ï¼Œ å‘å››å‘¨æ‰«ï¼Œ å…ˆæ‰«åˆ°çš„æ°´ç½‘æ ¼å¾—åˆ°çš„è‚¯å®šæ˜¯è·ç¦»æœ€è¿‘é™†åœ°çš„è·ç¦»ã€‚
        #åç»­æ›´æ–°ç½‘æ ¼å€¼ï¼Œæ¯ä¸ªç½‘æ ¼è¡¨ç¤ºè‡ªå·±åˆ°æœ€è¿‘é™†åœ°çš„è·ç¦»ã€‚
        shortest_dis = [[0] * m] * n
        #æ­¤å¤„æ³¨æ„visitedè¦è®¾ç½®ä¸ºsetï¼Œ listä¼šè¶…æ—¶ã€‚
        visited = set()
        while queue:
            cur = queue.pop(0)
            if (cur[0], cur[1]) in visited:
                continue
            else:
                visited.add((cur[0], cur[1]))
            #æ›´æ–°ç½‘æ ¼å€¼
            shortest_dis[cur[0]][cur[1]] = cur[2]
            #ç»§ç»­å‘è¯¥ç½‘æ ¼å››å‘¨æ‰«
            if cur[0] - 1 >= 0:
                queue.append((cur[0] - 1, cur[1], cur[2] + 1))
            if cur[0] + 1 < m:
                queue.append((cur[0] + 1, cur[1], cur[2] + 1))
            if cur[1] - 1 >= 0:
                queue.append((cur[0], cur[1] - 1, cur[2] + 1))
            if cur[1] + 1 < n:
                queue.append((cur[0], cur[1] + 1, cur[2] + 1))
        res = 0
        for i in range(len(shortest_dis[0])):
            for j in range(len(shortest_dis)):
                res = max(res, shortest_dis[i][j])
        return res
```

æœ¬é¢˜å†é™„åŠ ä¸€é“ç±»ä¼¼é¢˜ç›®ï¼š

åŸæ–‡è¿æ¥ï¼šhttps://blog.csdn.net/yurenguowang/article/details/77483402

é¢˜ç›®å¤§æ„ï¼š

ç»™ä¸€ä¸ª01çŸ©é˜µï¼Œæ±‚ä¸åŒçš„å²›å±¿çš„ä¸ªæ•°ã€‚

0ä»£è¡¨æµ·ï¼Œ1ä»£è¡¨å²›ï¼Œå¦‚æœä¸¤ä¸ª1ç›¸é‚»ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ª1å±äºåŒä¸€ä¸ªå²›ã€‚æˆ‘ä»¬åªè€ƒè™‘ä¸Šä¸‹å·¦å³ä¸ºç›¸é‚»ã€‚

æ ·ä¾‹ 

åœ¨çŸ©é˜µï¼š 
[ 

[1, 1, 0, 0, 0], 

[0, 1, 0, 0, 1], 

[0, 0, 0, 1, 1], 

[0, 0, 0, 0, 0],

[0, 0, 0, 0, 1] 

] 

ä¸­æœ‰3ä¸ªå²›ã€‚


 â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 
 
ç‰ˆæƒå£°æ˜ï¼šæœ¬æ–‡ä¸ºCSDNåšä¸»ã€Œæ„šäººå›½ç‹ã€çš„åŸåˆ›æ–‡ç« ï¼Œéµå¾ªCC 4.0 by-saç‰ˆæƒåè®®ï¼Œè½¬è½½è¯·é™„ä¸ŠåŸæ–‡å‡ºå¤„é“¾æ¥åŠæœ¬å£°æ˜ã€‚

åŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/yurenguowang/article/details/77483402

é¢˜ç›®è¯¦è§£ï¼šæ·±åº¦ä¼˜å…ˆæ€æƒ³ã€‚éå†çŸ©é˜µçš„æ¯ä¸ªå…ƒç´ ï¼Œå¦‚æœä¸º1åˆ™è®¡æ•°åŠ ä¸€ï¼ŒåŒæ—¶æŠŠè‡ªå·±å’Œå‘¨å›´çš„å…ƒç´ éƒ½ç½®0ã€‚

ç®—æ³•ï¼šdfs

```python
class Solution:
    # @param {boolean[][]} grid a boolean 2D matrix
    # @return {int} an integer
    def numIslands(self, grid):
        # Write your code here
        if grid is None:
            return None
        m = len(grid)
        if m == 0:
            return 0
        n = len(grid[0])
        if n == 0:
            return 0
        res = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    res += 1
                    self.dfs(grid, i, j)
        return res

    def dfs(self, grid, i, j):
        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]):
            return
        if grid[i][j]:
            grid[i][j] = 0
            self.dfs(grid, i + 1, j)
            self.dfs(grid, i - 1, j)
            self.dfs(grid, i, j - 1)
            self.dfs(grid, i, j + 1)
 â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” 
ç‰ˆæƒå£°æ˜ï¼šæœ¬æ–‡ä¸ºCSDNåšä¸»ã€Œæ„šäººå›½ç‹ã€çš„åŸåˆ›æ–‡ç« ï¼Œéµå¾ªCC 4.0 by-saç‰ˆæƒåè®®ï¼Œè½¬è½½è¯·é™„ä¸ŠåŸæ–‡å‡ºå¤„é“¾æ¥åŠæœ¬å£°æ˜ã€‚
åŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/yurenguowang/article/details/77483402
```
