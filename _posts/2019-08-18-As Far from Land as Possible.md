---
layout: post
title: Leetcode|As Far from Land as Possible|Python
---

é¢˜ç›®å¤§æ„ï¼šç»™ä¸€ä¸ªN * Nçš„ç½‘æ ¼ï¼Œ æ¯ä¸ªç½‘æ ¼æ˜¯0æˆ–1ï¼Œ 0ä»£è¡¨æ°´ï¼Œ1ä»£è¡¨é™†åœ°ï¼Œæ‰¾åˆ°ä¸€ä¸ªæ°´ç½‘æ ¼ä½¿å¾—å®ƒåˆ°å®ƒæœ€è¿‘çš„é™†åœ°è·ç¦»æ˜¯åœ¨æ‰€æœ‰æ°´ç½‘æ ¼åˆ°æœ€è¿‘é™†åœ°è·ç¦»ä¸­æ˜¯æœ€è¿œçš„ã€‚
ä»»æ„ä¸¤ä¸ªç½‘æ ¼ä¹‹é—´çš„è·ç¦»å…¬å¼ä¸º|x0 - x1| + |y0 - y1|ã€‚å¦‚æžœæ²¡æœ‰é™†åœ°æˆ–è€…æ²¡æœ‰æ°´ï¼Œ è¿”å›ž-1ã€‚

é¢˜ç›®è¯¦è§£ï¼šæœ¬é¢˜æ€è·¯æ¯”è¾ƒå·§å¦™ã€‚æŒ‰ç…§æ­£å¸¸é€»è¾‘ï¼Œ æˆ‘ä»¬ä¼šéåŽ†gridï¼Œ å¯¹äºŽæ¯ä¸€ä¸ªæ˜¯æ°´çš„ç½‘æ ¼è¿›è¡Œbfså‘å››å‘¨æ‰©æ•£ï¼Œ æ‰¾åˆ°ä¸€ä¸ªé™†åœ°ç«‹åˆ»è¿”å›žï¼Œ å³è¯¥æ°´ç½‘æ ¼åˆ°æœ€è¿‘é™†åœ°çš„æœ€çŸ­
è·ç¦»ã€‚ç„¶åŽæŠŠæ‰€æœ‰çš„æœ€çŸ­è·ç¦»è¿›è¡Œæ¯”è¾ƒæ‰¾åˆ°æœ€é•¿çš„ã€‚ä½†æ˜¯è¿™æ ·è€—æ—¶å¤ªä¹…ï¼Œ æ˜¯æ— æ³•é€šè¿‡çš„ã€‚

åæ–¹å‘æ€è€ƒðŸ˜”ï¼Œ å¦‚æžœæˆ‘ä»¬ä¸ä»Žæ°´å‡ºå‘bfsï¼Œ å¦‚æžœä»¥é™†åœ°ä¸ºåŸºå‡†bfså‘å››å‘¨ï¼ˆä¸Šä¸‹å·¦å³ï¼‰æ‰«ï¼Œ é‚£ä¹ˆå…ˆæ‰«åˆ°çš„å°±æ˜¯è·ç¦»é™†åœ°çš„æœ€è¿‘è·ç¦»ï¼Œ è¿™æ ·è®²å¤§å¤§åŠ å¿«æ•ˆçŽ‡ã€‚ å½“æ‰€æœ‰ç½‘æ ¼
éƒ½è¢«æ‰«è¿‡ï¼Œ æ‰€æœ‰æ°´ç½‘æ ¼åˆ°é™†åœ°çš„æœ€å°è·ç¦»ä¹Ÿå°±éƒ½å‡ºæ¥äº†ï¼Œ ä»Žä¸­é€‰å–æœ€å¤§çš„å³å¯ã€‚

ç®—æ³•ï¼šfloodfillï¼ˆbfsï¼‰

```python
class Solution(object):
    def maxDistance(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        m = len(grid[0])
        n = len(grid)
        sum = 0
        queue = []
        for i in range(m):
            for j in range(n):
                sum += grid[i][j]
                #å…ˆæŠŠæ‰€æœ‰é™†åœ°çš„ç½‘æ ¼åŠ åˆ°é˜Ÿåˆ—é‡Œé¢
                if grid[i][j] == 1:
                    queue.append((i, j, 0))
        #å…¨æ˜¯é™†åœ°æˆ–å…¨æ˜¯æ°´ï¼Œ è¿”å›ž-1ã€‚
        if sum == 0 or sum == m * n:
            return -1
        #å»ºç«‹ä¸€ä¸ªå…¨æ˜¯0çš„ç›¸åŒå¤§å°ç½‘æ ¼ï¼Œåæ–¹å‘æ€è€ƒï¼Œ ä»¥é™†åœ°ä¸ºåŸºå‡†ï¼Œ å‘å››å‘¨æ‰«ï¼Œ å…ˆæ‰«åˆ°çš„æ°´ç½‘æ ¼å¾—åˆ°çš„è‚¯å®šæ˜¯è·ç¦»æœ€è¿‘é™†åœ°çš„è·ç¦»ã€‚
        #åŽç»­æ›´æ–°ç½‘æ ¼å€¼ï¼Œæ¯ä¸ªç½‘æ ¼è¡¨ç¤ºè‡ªå·±åˆ°æœ€è¿‘é™†åœ°çš„è·ç¦»ã€‚
        shortest_dis = [[0] * m] * n
        #æ­¤å¤„æ³¨æ„visitedè¦è®¾ç½®ä¸ºsetï¼Œ listä¼šè¶…æ—¶ã€‚
        visited = set()
        while queue:
            cur = queue.pop(0)
            if (cur[0], cur[1]) in visited:
                continue
            else:
                visited.add((cur[0], cur[1]))
            #æ›´æ–°ç½‘æ ¼å€¼
            shortest_dis[cur[0]][cur[1]] = cur[2]
            #ç»§ç»­å‘è¯¥ç½‘æ ¼å››å‘¨æ‰«
            if cur[0] - 1 >= 0:
                queue.append((cur[0] - 1, cur[1], cur[2] + 1))
            if cur[0] + 1 < m:
                queue.append((cur[0] + 1, cur[1], cur[2] + 1))
            if cur[1] - 1 >= 0:
                queue.append((cur[0], cur[1] - 1, cur[2] + 1))
            if cur[1] + 1 < n:
                queue.append((cur[0], cur[1] + 1, cur[2] + 1))
        res = 0
        for i in range(len(shortest_dis[0])):
            for j in range(len(shortest_dis)):
                res = max(res, shortest_dis[i][j])
        return res
```
